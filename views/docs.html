<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Documentation</title>
    <link rel="stylesheet" href="../styles/docs.css">
    <!-- <link rel="stylesheet" href="../styles/nav.css"> -->
  </head>
  <body>
    <div class="navCont">
      <a href="../index.html"><div class="logo">Mini Projects</div></a>
    </div>
   <nav id="navbar" >
  <header>C++ STL</header>
  <ul>
    <li><a class="nav-link" href="#Introduction">Introduction to STL</a></li>
    <li>
      
      <a class="nav-link" href="#Algorithms">Algorithms in STL</a>
    </li>
    <li>
      <a class="nav-link" href="#Containers">Containers in STL</a>
    </li>
    <li><a class="nav-link" href="#Functions">Functions in STL</a></li>
    <li><a class="nav-link" href="#Iterators">Iterators in STL</a></li>
    <li>
      <a class="nav-link" href="#Examples">Examples</a>
    </li>
    <li><a class="nav-link" href="#Reference">Reference</a></li>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="Introduction">
    <header>The C++ Standard Template Library (STL)</header>
    <article>
      <p>
        The Standard Template Library (STL) is a set of C++ template classes to provide common programming data structures and functions such as lists, stacks, arrays, etc. It is a library of container classes, algorithms, and iterators. It is a generalized library and so, its components are parameterized. A working knowledge of template classes is a prerequisite for working with STL.
      </p>

      <p>
       <strong> STL has four components :</strong>
      </p>
      <ul>
        <li>
          Algorithms
        </li>
        <li>
          Containers
        </li>
        <li>
          Functions
        </li>
        <li>
          Iterators
        </li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="Algorithms">
    <header>Algorithms</header>
    <article>
      <p>The header algorithm defines a collection of functions especially designed to be used on ranges of elements.They act on containers and provide means for various operations for the contents of the containers.</p>

      <ul>
        <li>
          Sorting Algorithms
          <code><pre>sort(startaddress, endaddress)

startaddress: the address of the first 
              element of the array
endaddress: the address of the next 
            contiguous location of the 
            last element of the array.
So actually sort() sorts in the 
range of [startaddress,endaddress)
</pre></code>
        </li>
        <li>Searching Algorithms
        <code>
          <pre><strong>binary_search(startaddress, 
              endaddress, valuetofind)</strong>
<strong>Parameters :</strong>
startaddress: the address of the first 
              element of the array.
endaddress: the address of the next contiguous 
            location of the last element of the array.
valuetofind: the target value which we have 
             to search for.
<strong>Returns :</strong>
true if an element equal to valuetofind is found, else false.</pre>
        </code>
        </li>
        <li>sort(first_iterator, last_iterator) – To sort the given vector.</li>
<li>reverse(first_iterator, last_iterator) – To reverse a vector.</li>
<li>*max_element (first_iterator, last_iterator) – To find the maximum element of a vector.</li>
        <li>*min_element (first_iterator, last_iterator) – To find the minimum element of a vector.</li>
<li>accumulate(first_iterator, last_iterator, initial value of sum) – Does the summation of vector elements
        </li>
        <li>count(first_iterator, last_iterator,x) – To count the occurrences of x in vector.</li>
     <li>find(first_iterator, last_iterator, x) – Points to last address of vector ((name_of_vector).end()) if element is not present in             vector.</li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="Containers">
    <header>Containers</header>
    <article>
      <p>
       Containers or container classes store objects and data. There are in total seven standard          “first-class” container classes and three container adaptor classes and only seven header           files that provide access to these containers or container adaptors.
      </p>
      <ul>
        <li>
          Sequence Containers:  implement data structures which can be accessed in a sequential 
          manner.
          <ul>
            <li>vector</li>
            <li>list</li>
            <li>deque</li>
            <li>arrays</li>
            <li>forward_list( Introduced in C++11)</li>
          </ul>
        </li>
        <li>
          Container Adaptors : provide a different interface for sequential containers.
          <ul>
            <li>queue</li>
            <li>Priority queue</li>
            <li>stack</li>
          </ul>
        </li>
        <li>
          Associative Containers : implement sorted data structures that can be quickly searched             (O(log n) complexity).
          <ul>
            <li>set</li>
            <li>multiset</li>
            <li>map</li>
            <li>multimap</li>
          </ul>
        </li>
        <li>
          Unordered Associative Containers : implement unordered data structures that can be                quickly searched
          <ul>
            <li>unordered set</li>
            <li>unordered multiset</li>
            <li>unordered map</li>
            <li>unordered multimap</li>
          </ul>
        </li>
      </ul>
      
    </article>
  </section>
  <section class="main-section" id="Functions">
    <header>Functions</header>
    <article>
      <p>The STL includes classes that overload the function call operator. Instances of such classes      are called function objects or functors. Functors allow the working of the associated             function to be customized with the help of parameters to be passed.</p>
      <ul>
        <li>Functors</li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="Iterators">
    <header>Iterators in STL</header>
    <article>
    <p> As the name suggests, iterators are used for working upon a sequence of values. They are the major feature that allow generality in STL.</p>
    </article>
  </section>
  <section class="main-section" id="Examples">
    <header>Some Examples</header>
    <ul>
      <li>Sort an Array Using STL Sort<br>
        <code>
<pre>
// C++ progrma to sort an array
#include &lt algorithm>
#include &lt iostream> 
using namespace std;
 
void show(int a[], int array_size)
{
    for (int i = 0; i &lt array_size; ++i)
        cout << a[i] << " ";
}
// Driver code
int main()
{
    int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 };  
    // size of the array
    int asize = sizeof(a) / sizeof(a[0]);
    cout << "The array before sorting is : \n";
    // print the array
    show(a, asize);
      // sort the array
    sort(a, a + asize);
    cout << "\n\nThe array after sorting is :\n";
    // print the array after sorting
    show(a, asize);
    return 0;
}
          </pre>
        </code>
      </li>
      <li>
        Serarcing in array<br>
        <code>
          <pre>
// CPP program to implement
// Binary Search in
// Standard Template Library (STL)
#include &lt algorithm &gt
#include &lt iostream &gt
using namespace std;
void show(int a[], int arraysize)
{
	for (int i = 0; i $lt arraysize; ++i)
		cout << a[i] << ",";
}
int main()
{
	int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 };
	int asize = sizeof(a) / sizeof(a[0]);
	cout << "\nThe array is : \n";
	show(a, asize);
	sort(a, a + asize);
	show(a, asize);
	if (binary_search(a, a + 10, 2))
		cout << "\nElement found in the array";
	else
		cout << "\nElement not found in the array";
	cout << "\n\nNow, say we want to search for 10";
	if (binary_search(a, a + 10, 10))
		cout << "\nElement found in the array";
	else
		cout << "\nElement not found in the array";
	return 0;
}

          </pre>
        </code>
      </li>
      <li>Some Smart Algorithms<br>
        <code>
          <pre>
// A C++ program to demonstrate working of sort(),
// reverse()
#include &lt algorithm>
#include &lt iostream>
#include &lt vector>
#include &lt numeric> //For accumulate operation
using namespace std;

int main()
{
	// Initializing vector with array values
	int arr[] = {10, 20, 5, 23 ,42 , 15};
	int n = sizeof(arr)/sizeof(arr[0]);
	vector<int> vect(arr, arr+n);

	cout << "Vector is: ";
	for (int i=0; i &lt n; i++)
		cout << vect[i] << " ";

	// Sorting the Vector in Ascending order
	sort(vect.begin(), vect.end());

	cout << "\nVector after sorting is: ";
	for (int i=0; i&lt n; i++)
	cout << vect[i] << " ";

	// Reversing the Vector
	reverse(vect.begin(), vect.end());

	cout &lt &lt "\nVector after reversing is: ";
	for (int i=0; i &lt 6; i++)
		cout << vect[i] << " ";

	cout << "\nMaximum element of vector is: ";
	cout << *max_element(vect.begin(), vect.end());

	cout << "\nMinimum element of vector is: ";
	cout << *min_element(vect.begin(), vect.end());

	// Starting the summation from 0
	cout << "\nThe summation of vector elements is: ";
	cout << accumulate(vect.begin(), vect.end(), 0);

	return 0;
}

</pre>
        </code>
      </li>
    </ul>
  </section>
  <section class="main-section" id="Reference">
    <header>For More Detaited Explanation</header>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/" target="_blank">GeeksForGeeks</a></li>
    </ul>
  </section>
  </section>
  <section class="main-section" id="CC-Claim">
     <span >&#169 By<b> Avinash Jha</b> 2022</span>
  </section>
</main>
  <section class="footer">
      <h3>Created By &copy; Avinash Jha on 15/04/2022</h3>
    </section>
  </body>
</html>
